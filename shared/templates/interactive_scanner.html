<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktiver Bestellungs-Scanner</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            padding-right: 10px;
            background: #1a1a2e;
            color: #eee;
            overflow-x: hidden;
        }
        h1 { color: #00d4ff; margin-bottom: 10px; }
        .container {
            display: flex;
            gap: 20px;
            width: 100%;
            margin: 0;
        }
        .image-panel {
            flex: 0 0 auto;
            position: relative;
        }
        .sidebar {
            flex: 1;
            min-width: 450px;
            position: sticky;
            top: 10px;
            align-self: flex-start;
            max-height: 95vh;
            overflow-y: auto;
            padding-right: 10px;
        }
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: #1a1a2e;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: #0f4c75;
            border-radius: 4px;
        }
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #00d4ff;
        }
        #canvasContainer {
            position: relative;
            display: inline-block;
            border: 2px solid #333;
            background: #000;
            overflow: auto;
            max-height: 85vh;
        }
        #mainCanvas {
            display: block;
            cursor: crosshair;
        }
        .panel {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }
        .panel h3 {
            margin: 0 0 15px 0;
            color: #00d4ff;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            font-size: 18px;
        }
        .btn {
            background: #0f4c75;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px 5px 5px 0;
            display: inline-block;
            transition: box-shadow 0.3s;
        }
        .btn:hover { background: #1a6fa8; }
        .btn:disabled { background: #333; cursor: not-allowed; animation: none !important; box-shadow: none !important; }
        .btn.primary { background: #00d4ff; color: #000; font-weight: bold; }
        .btn.primary:hover { background: #00a8cc; }
        .btn.success { background: #28a745; }
        .btn.danger { background: #dc3545; }
        .btn.small { padding: 8px 14px; font-size: 14px; }

        /* Blinking button for user guidance */
        .btn.guide-blink {
            animation: btnBlink 1.2s ease-in-out infinite;
        }
        @keyframes btnBlink {
            0%, 100% {
                box-shadow: 0 0 5px rgba(0, 212, 255, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(0, 212, 255, 1), 0 0 40px rgba(0, 212, 255, 0.7), 0 0 60px rgba(0, 212, 255, 0.4);
            }
        }
        .btn.primary.guide-blink {
            animation: btnBlinkPrimary 1.2s ease-in-out infinite;
        }
        @keyframes btnBlinkPrimary {
            0%, 100% {
                box-shadow: 0 0 5px rgba(0, 255, 200, 0.5);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px rgba(0, 255, 200, 1), 0 0 50px rgba(0, 255, 200, 0.7);
                transform: scale(1.02);
            }
        }
        .btn.success.guide-blink {
            animation: btnBlinkSuccess 1.2s ease-in-out infinite;
        }
        @keyframes btnBlinkSuccess {
            0%, 100% {
                box-shadow: 0 0 5px rgba(40, 167, 69, 0.5);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px rgba(40, 167, 69, 1), 0 0 50px rgba(40, 167, 69, 0.7);
                transform: scale(1.02);
            }
        }

        /* Results table */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 15px;
        }
        .results-table th, .results-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        .results-table th { color: #00d4ff; font-size: 14px; }
        .results-table tr:hover { background: rgba(0, 212, 255, 0.1); }
        .results-table tr.selected { background: rgba(0, 212, 255, 0.3); }
        .results-table tr.highlighted {
            background: rgba(0, 255, 255, 0.4) !important;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        .results-table .quantity-input {
            background: #1a5a8a;
            border: 2px solid #00d4ff;
            color: #fff;
            width: 55px;
            text-align: center;
            padding: 8px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: text;
        }
        .results-table .quantity-input:hover {
            background: #2070a0;
            border-color: #00ffff;
        }
        .results-table .quantity-input:focus {
            outline: none;
            background: #2080b0;
            border-color: #00ffff;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
        }

        /* Review modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: #16213e;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
        }
        .review-image {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            display: inline-block;
        }
        .review-image img {
            max-width: 250px;
            max-height: 120px;
            image-rendering: pixelated;
        }
        .digit-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        .digit-btn {
            width: 50px;
            height: 50px;
            font-size: 24px;
            font-weight: bold;
            border: 2px solid #00d4ff;
            background: transparent;
            color: #00d4ff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .digit-btn:hover {
            background: #00d4ff;
            color: #000;
        }

        /* Stats */
        .stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .stat-box {
            background: #0f4c75;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            flex: 1;
            min-width: 90px;
        }
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #00d4ff;
        }
        .stat-label {
            font-size: 13px;
            color: #aaa;
            margin-top: 5px;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            background: #0f4c75;
            font-size: 13px;
            transition: background-color 0.3s;
        }
        .status.active {
            animation: blink 1s ease-in-out infinite;
        }
        @keyframes blink {
            0%, 100% { background: #0f4c75; }
            50% { background: #1a8cff; }
        }

        /* Progress bar styles */
        .progress-container {
            display: none;
            margin-top: 10px;
            background: #0a3d62;
            border-radius: 8px;
            padding: 12px;
        }
        .progress-container.active {
            display: block;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .progress-step {
            color: #00d4ff;
            font-weight: bold;
        }
        .progress-percent {
            color: #fff;
            font-weight: bold;
        }
        .progress-bar-outer {
            background: #1a1a2e;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        .progress-bar-inner {
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            height: 100%;
            width: 0%;
            border-radius: 10px;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        .progress-detail {
            margin-top: 8px;
            font-size: 12px;
            color: #aaa;
        }

        .instructions {
            background: #0a3d62;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.5;
        }
        .instructions strong { color: #00d4ff; }

        .mode-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        .mode-zone { background: #e74c3c; }
        .mode-review { background: #27ae60; }
    </style>
</head>
<body>
    <header style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px; justify-content: space-between;">
        <div style="display: flex; align-items: center; gap: 15px;">
            <img src="/fertigsalat_Logo.png" alt="Fertigsalat Logo" style="height: 50px;">
            <h1 style="margin: 0;">Interaktiver Bestellungs-Scanner <span class="mode-indicator" id="modeIndicator">Modus: Zone definieren</span></h1>
        </div>
    </header>

    <div class="container">
        <div class="image-panel">
            <div class="panel">
                <h3>Dokument</h3>
                <div class="instructions" id="instructions">
                    <strong>Schritt 1:</strong> Klicken Sie "Datei laden" und w√§hlen Sie eine .eml-Datei oder ein Bild aus. Bei E-Mails werden Anh√§nge automatisch extrahiert.
                </div>
                <div id="canvasContainer">
                    <canvas id="mainCanvas"></canvas>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="panel">
                <h3>Steuerung</h3>
                <input type="file" id="fileInput" accept="image/*,.eml" style="display:none" onchange="handleFileSelect(this)">
                <button class="btn primary guide-blink" id="loadFileBtn" onclick="document.getElementById('fileInput').click()" title="EML-Datei oder Bild laden">1. Datei laden</button>
                <button class="btn danger" onclick="clearAllZones()" title="Alle definierten Zonen l√∂schen">Alle Zonen l√∂schen</button>
                <button class="btn" onclick="autoDetectZones()" id="autoDetectBtn" style="background:#9b59b6;" title="Automatisch Zonen erkennen (OCR-basiert)">Zone auto-erkennen</button>
                <button class="btn" onclick="rotateDocument()" id="rotateBtn" style="background:#e67e22;" title="Dokument um 180¬∞ drehen und Deskew anwenden">Dokument drehen</button>
                <br>
                <button class="btn success" onclick="scanZone()" id="scanBtn" disabled title="Handschriftliche Ziffern in den Zonen erkennen">2. Zone scannen</button>
                <button class="btn" onclick="reviewNext()" id="reviewBtn" disabled title="Zur n√§chsten unsicheren Erkennung springen">N√§chstes pr√ºfen</button>
            </div>

            <div class="panel">
                <h3>Zonen definieren</h3>
                <p style="font-size:12px; color:#aaa; margin-bottom:10px;">Klicken Sie einen Button und zeichnen Sie die Zone im Bild:</p>
                <button class="btn zone-btn" id="btnZoneOrders" onclick="handleOrdersButtonClick(event)" style="background:#00d4ff; color:#000;" title="Klick: Zone zeichnen | Shift+Klick: Letzte Zone l√∂schen">Bestellmengen (0/2)</button>
                <button class="btn zone-btn" id="btnZoneNames" onclick="setActiveZone('names')" style="background:#00ff00; color:#000;" title="Klick: Zone zeichnen (√ºberschreibt vorherige)">Produktnamen</button>
                <button class="btn zone-btn" id="btnZoneCodes" onclick="handleCodesButtonClick(event)" style="background:#ff9800; color:#000;" title="Klick: Zone zeichnen | Shift+Klick: Letzte Zone l√∂schen">Produktnummern (0/3)</button>
                <div id="activeZoneInfo" style="margin-top:10px; padding:8px; background:#0a3d62; border-radius:5px; font-size:12px;">
                    Aktiv: <strong id="activeZoneName">Bestellmengen</strong>
                </div>
            </div>

            <div class="panel">
                <h3>Erkannte Objekte bearbeiten</h3>
                <p style="font-size:12px; color:#aaa; margin-bottom:10px;">Markieren Sie einen Bereich im Bild:</p>
                <button class="btn edit-btn" id="btnDeleteObjects" onclick="setEditMode('delete')" style="background:#dc3545;">Objekte l√∂schen</button>
                <button class="btn edit-btn" id="btnAddObject" onclick="setEditMode('add')" style="background:#28a745;">Objekt hinzuf√ºgen</button>
                <div id="editModeInfo" style="margin-top:10px; padding:8px; background:#0a3d62; border-radius:5px; font-size:12px; display:none;">
                    <span id="editModeText"></span>
                </div>
            </div>

            <div class="panel" id="zonePanel" style="display:none;">
                <h3>Zonen-Status</h3>
                <div id="zoneInfo"></div>
                <div style="margin-top:15px; font-size:15px;">
                    <label>Zeilen: <input type="number" id="numRows" value="52" min="1" max="100" style="width:60px; padding:6px; font-size:15px; background:#0f4c75; color:#fff; border:1px solid #00d4ff; border-radius:4px;"></label>
                    <label style="margin-left:15px;">Spalten: <input type="number" id="numCols" value="5" min="1" max="10" style="width:60px; padding:6px; font-size:15px; background:#0f4c75; color:#fff; border:1px solid #00d4ff; border-radius:4px;"></label>
                </div>
            </div>

            <div class="panel">
                <h3>Statistik</h3>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-value" id="statTotal">0</div>
                        <div class="stat-label">Erkannt</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statReviewed">0</div>
                        <div class="stat-label">Gepr√ºft</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statPending">0</div>
                        <div class="stat-label">Offen</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Erkannte Bestellungen (<span id="orderCount">0</span>)</h3>
                <div style="margin-bottom:10px; padding:10px; background:#1a1a2e; border-radius:5px; display:flex; gap:15px; align-items:center;">
                    <div style="display:flex; align-items:center; gap:5px;">
                        <label for="customerNumberInput" style="color:#e91e63; font-weight:bold;">Kundennummer:</label>
                        <input type="text" id="customerNumberInput" placeholder="z.B. M90" style="width:100px; padding:5px 8px; border:1px solid #e91e63; border-radius:4px; background:#2a2a3e; color:#fff;">
                    </div>
                    <div style="display:flex; align-items:center; gap:5px;">
                        <label for="kwInput" style="color:#00d4ff; font-weight:bold;">KW:</label>
                        <input type="text" id="kwInput" placeholder="z.B. 03" style="width:60px; padding:5px 8px; border:1px solid #00d4ff; border-radius:4px; background:#2a2a3e; color:#fff;">
                    </div>
                </div>
                <div>
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Menge</th>
                                <th>Produktname</th>
                                <th>Produkt-Nr.</th>
                                <th>Tag</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="resultsBody">
                            <tr><td colspan="5" style="text-align:center;color:#666;">Noch keine Ergebnisse</td></tr>
                        </tbody>
                    </table>
                </div>
                <button class="btn success" onclick="exportResults()" style="margin-top:10px;">Export JSON</button>
            </div>

            <div class="panel">
                <h3>Training Status</h3>
                <div id="trainingStats" style="font-size: 12px; color: #aaa;">Lade...</div>
                <button class="btn small" onclick="loadTrainingStats()" style="margin-top: 8px;">Aktualisieren</button>
            </div>

            <div class="panel">
                <div class="status" id="status">Bereit. Klicke "Datei laden" um eine E-Mail (.eml) oder ein Bild zu √∂ffnen.</div>
                <div class="progress-container" id="progressContainer">
                    <div class="progress-header">
                        <span class="progress-step" id="progressStep">Schritt 1/7</span>
                        <span class="progress-percent" id="progressPercent">0%</span>
                    </div>
                    <div class="progress-bar-outer">
                        <div class="progress-bar-inner" id="progressBar"></div>
                    </div>
                    <div class="progress-detail" id="progressDetail">Starte Verarbeitung...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Attachment Selection Modal -->
    <div class="modal" id="attachmentModal">
        <div class="modal-content" style="max-width: 600px;">
            <h3>Anhang ausw√§hlen</h3>
            <p id="emlInfo" style="color: #aaa; font-size: 13px;"></p>
            <div id="attachmentList" style="max-height: 400px; overflow-y: auto; margin: 20px 0;"></div>
            <button class="btn" onclick="closeAttachmentModal()">Abbrechen</button>
        </div>
    </div>

    <!-- Review Modal -->
    <div class="modal" id="reviewModal">
        <div class="modal-content">
            <h3>Zeichen identifizieren</h3>
            <p id="reviewContext">Zeile X, Spalte Y</p>
            <div class="review-image">
                <img id="reviewImage" src="" alt="Zeichen">
            </div>
            <p>Welche Ziffer ist das?</p>
            <div class="digit-buttons">
                <button class="digit-btn" onclick="setDigit('1')">1</button>
                <button class="digit-btn" onclick="setDigit('2')">2</button>
                <button class="digit-btn" onclick="setDigit('3')">3</button>
                <button class="digit-btn" onclick="setDigit('4')">4</button>
                <button class="digit-btn" onclick="setDigit('5')">5</button>
                <button class="digit-btn" onclick="setDigit('6')">6</button>
                <button class="digit-btn" onclick="setDigit('7')">7</button>
                <button class="digit-btn" onclick="setDigit('8')">8</button>
                <button class="digit-btn" onclick="setDigit('9')">9</button>
                <button class="digit-btn" onclick="setDigit('0')">0</button>
            </div>
            <div>
                <button class="btn danger" onclick="setDigit('empty')">Leer / Kein Zeichen</button>
                <button class="btn" onclick="closeModal()">Abbrechen</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let image = null;
        let imageData = null;

        // Three separate zones
        // Note: orders and codes are arrays (multiple zones), names is single object
        let zones = {
            orders: [],    // Bestellmengen - cyan (array, max 2: Mo-Fr + Sa)
            names: null,   // Produktnamen - green
            codes: []      // Produktnummern - orange (array, max 3)
        };
        const MAX_ORDER_ZONES = 2;  // Mo-Fr + Samstag
        const MAX_CODE_ZONES = 3;
        let activeZone = 'orders';  // Currently selected zone for drawing
        let editMode = null;  // null, 'delete', 'add' - for object editing

        let isDrawing = false;
        let drawStart = null;
        let editSelectionRect = null;  // Rectangle for delete/add selection
        let currentDrawingRect = null; // Temporary rectangle while drawing (for codes array)
        let results = [];
        let currentReviewIndex = -1;

        // Corner/edge dragging state
        const HANDLE_SIZE = 12;  // Size of corner handles in pixels
        const HANDLE_HIT_RADIUS = 15;  // Hit detection radius
        let dragState = null;  // { zoneKey, codesIndex?, handle: 'tl'|'tr'|'bl'|'br'|'move', startX, startY, origZone }
        // Handle positions: tl=top-left, tr=top-right, bl=bottom-left, br=bottom-right, move=center

        // Static product lookup table (quasi-static form layout)
        // Row index (0-based) -> { name, code }
        const PRODUCT_TABLE = {
            0:  { name: 'Monatssalat', code: '200' },
            1:  { name: 'Jahreszeitensalat', code: '201' },
            2:  { name: 'Saisonsalat', code: '202' },
            3:  { name: 'Salade M√©diterran√©e', code: '203' },
            4:  { name: 'M√§ritsalat', code: '204' },
            5:  { name: 'Cleopatra-Salat', code: '205' },
            6:  { name: 'Salade Taboul√©', code: '206' },
            7:  { name: 'N√ºsslisalat mit Speck und Ei', code: '207' },
            8:  { name: 'N√ºsslisalat mit Ei', code: '208' },
            9:  { name: 'Salade Caprese', code: '209' },
            10: { name: 'Power-Salat', code: '210' },
            11: { name: 'B√§rner Quinoa-Linsensalat', code: '211' },
            12: { name: 'Griechischer Salat', code: '212' },
            13: { name: 'Gr√ºner Salat mit R√ºebli & Kernen', code: '213' },
            14: { name: 'Gr√ºner Salat mit H√ºttenk√§se', code: '214' },
            15: { name: 'Gr√ºner Salat gemischt (gross)', code: '215' },
            16: { name: 'Gr√ºner Salat mit Poulet & Peperoni', code: '216' },
            17: { name: 'Gr√ºner Salat "Chly"', code: '217' },
            18: { name: 'Gr√ºner Salat mit R√ºebli & Kernen (klein)', code: '218' },
            19: { name: 'Gr√ºner Salat mit Gurken und Ei', code: '219' },
            20: { name: 'Gr√ºner Salat mit Tomaten, Ei und K√§se', code: '220' },
            21: { name: 'Gr√ºner Salat gemischt (klein)', code: '221' },
            22: { name: 'Randensalat mit H√ºttenk√§se', code: '222' },
            23: { name: 'Bohnen-Feta Salat', code: '223' },
            24: { name: 'Sandwiches (Kategorie)', code: '' },
            25: { name: 'Sandwich Crustino mit Schinken', code: '230' },
            26: { name: 'Weggli mit Schinken', code: '231' },
            27: { name: 'Sandwich Crustino mit K√§se', code: '232' },
            28: { name: 'Weggli mit K√§se', code: '233' },
            29: { name: 'Zopf mit Schinken-K√§se', code: '234' },
            30: { name: 'Ruchbrot mit Schinken-K√§se', code: '235' },
            31: { name: 'Ruchbrot mit Salami', code: '236' },
            32: { name: 'Laugensandwich mit Kr√§uterfrischk√§se', code: '237' },
            33: { name: 'Laugensilserli mit Kr√§uterfrischk√§se', code: '238' },
            34: { name: 'Laugensilserli mit Thon', code: '239' },
            35: { name: 'Ciabatta mit Thon', code: '240' },
            36: { name: 'Ciabatta mit Roastbeef', code: '241' },
            37: { name: 'Schraubenbrot mit Schnitzel', code: '242' },
            38: { name: 'Maggia-Parisettli Caprese', code: '243' },
            39: { name: 'Maggia-Parisettli mit Brie', code: '244' },
            40: { name: 'Maggia-Parisettli mit Trockenfleisch', code: '245' },
            41: { name: 'Weitere Produkte (Kategorie)', code: '' },
            42: { name: 'Bircherm√ºesli mit Waldbeeren klein', code: '250' },
            43: { name: 'Bircherm√ºesli mit Waldbeeren gross', code: '251' },
            44: { name: 'Wrap mit B√§rner Quinoa & Roastbeef', code: '252' },
            45: { name: 'Wrap Taboul√©', code: '253' },
            46: { name: 'Suppen (Kategorie)', code: '' },
            47: { name: 'Rassige Tomatensuppe', code: '260' },
            48: { name: 'R√ºebli-Zucchettisuppe', code: '261' },
            49: { name: 'Lauch-Specksuppe', code: '262' },
            50: { name: 'Saisonsuppe', code: '263' },
            51: { name: 'Reservezeile', code: '' }
        };

        // Helper function to get product info by row
        function getProductInfo(rowIndex) {
            const product = PRODUCT_TABLE[rowIndex];
            if (product) {
                return { name: product.name, code: product.code };
            }
            return { name: `Zeile ${rowIndex + 1}`, code: '' };
        }
        let highlightedResultIndex = -1;
        let highlightPulse = 0;  // For pulsing animation
        let highlightAnimationId = null;

        // Start highlight animation
        function startHighlightAnimation() {
            if (highlightAnimationId) return;
            function animate() {
                highlightPulse = (highlightPulse + 0.15) % (Math.PI * 2);
                if (highlightedResultIndex >= 0) {
                    redraw();
                    highlightAnimationId = requestAnimationFrame(animate);
                } else {
                    highlightAnimationId = null;
                }
            }
            highlightAnimationId = requestAnimationFrame(animate);
        }

        function stopHighlightAnimation() {
            if (highlightAnimationId) {
                cancelAnimationFrame(highlightAnimationId);
                highlightAnimationId = null;
            }
        }

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const COLUMNS = ['Mo', 'Di', 'Mi', 'Do', 'Fr'];

        const ZONE_COLORS = {
            orders: { stroke: '#00d4ff', fill: 'rgba(0, 212, 255, 0.1)', name: 'Bestellmengen' },
            names: { stroke: '#00ff00', fill: 'rgba(0, 255, 0, 0.1)', name: 'Produktnamen' },
            codes: { stroke: '#ff9800', fill: 'rgba(255, 152, 0, 0.1)', name: 'Produktnummern' }
        };

        // Canvas event handlers
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', drawing);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseleave', endDraw);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('dblclick', handleCanvasDblClick);

        function handleFileSelect(input) {
            if (!input.files || !input.files[0]) return;

            const file = input.files[0];

            // Reset state before loading new file
            resetState();

            if (file.name.toLowerCase().endsWith('.eml')) {
                loadEmlFile(file);
            } else {
                loadImageFile(file);
            }

            // Reset file input so the same file can be selected again
            input.value = '';
        }

        // Reset all state when loading a new file
        function resetState() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset image references
            if (imageData && imageData.startsWith('blob:')) {
                URL.revokeObjectURL(imageData);
            }
            image = null;
            imageData = null;

            // Reset zones
            zones = { orders: [], names: null, codes: [] };
            activeZone = 'orders';
            updateOrdersButtonText();
            updateCodesButtonText();

            // Reset edit mode
            editMode = null;
            editSelectionRect = null;
            document.getElementById('editModeInfo').style.display = 'none';
            document.querySelectorAll('.edit-btn').forEach(btn => {
                btn.style.opacity = '1';
                btn.style.border = 'none';
            });

            // Reset results
            results = [];
            currentReviewIndex = -1;
            highlightedResultIndex = -1;

            // Stop highlight animation
            if (highlightAnimationId) {
                cancelAnimationFrame(highlightAnimationId);
                highlightAnimationId = null;
            }
            highlightPulse = 0;

            // Reset drawing state
            isDrawing = false;
            drawStart = null;

            // Reset UI elements
            document.getElementById('scanBtn').disabled = true;
            document.getElementById('reviewBtn').disabled = true;
            document.getElementById('resultsBody').innerHTML =
                '<tr><td colspan="5" style="text-align:center;color:#666;">Noch keine Ergebnisse</td></tr>';
            document.getElementById('orderCount').textContent = '0';
            document.getElementById('customerNumberInput').value = '';
            document.getElementById('kwInput').value = '';

            // Reset statistics
            document.getElementById('statTotal').textContent = '0';
            document.getElementById('statReviewed').textContent = '0';
            document.getElementById('statPending').textContent = '0';

            // Reset zone info panel
            document.getElementById('zonePanel').style.display = 'none';
            updateZoneInfo();

            // Reset zone button styles
            setActiveZone('orders');

            // Reset mode indicator
            setMode('zone');
            setGuideStep('load');

            // Reset status
            setStatus('Bereit. Lade eine Datei...');
        }

        function loadImageFile(file) {
            setStatus('Lade Bild: ' + file.name);

            imageData = URL.createObjectURL(file);

            image = new Image();
            image.onload = function() {
                canvas.width = image.width;
                canvas.height = image.height;

                // Auto-detect zone based on template coordinates
                suggestZone();

                redraw();
                setStatus('Bild geladen: ' + file.name + '. Klicken Sie "Zone auto-erkennen".');
                setMode('zone');
                setGuideStep('detect');  // Highlight auto-detect button
                document.getElementById('instructions').innerHTML =
                    '<strong>Schritt 2:</strong> Klicken Sie auf "Zone auto-erkennen" um die Tabellenbereiche automatisch zu erkennen.';
            };
            image.onerror = function() {
                setStatus('Fehler: Datei konnte nicht als Bild geladen werden.');
            };
            image.src = imageData;
        }

        async function loadEmlFile(file) {
            setStatus('Verarbeite E-Mail: ' + file.name, true);

            // Progress indicator during server processing
            const progressSteps = [
                { text: 'Sende an Server...', detail: 'Datei wird hochgeladen', duration: 500 },
                { text: 'Extrahiere PDF-Anh√§nge...', detail: 'E-Mail wird analysiert', duration: 800 },
                { text: 'Konvertiere PDF zu Bild...', detail: '300 DPI Aufl√∂sung', duration: 1200 },
                { text: 'Erkenne Dokumentausrichtung...', detail: 'OCR-basierte Analyse', duration: 2000 },
                { text: 'Korrigiere Orientierung...', detail: 'Automatische Drehung', duration: 1000 },
                { text: 'Wende Deskew an...', detail: 'Linien-Erkennung f√ºr Ausrichtung', duration: 1500 },
                { text: 'Optimiere Bild...', detail: 'Finale Bildverarbeitung', duration: 5000 }
            ];

            let currentStep = 0;
            let currentPercent = 0;
            let targetPercent = 0;
            let simulatedPercent = 0;
            showProgress(true);
            updateProgress(0, progressSteps[0].text, progressSteps[0].detail, 1, progressSteps.length);

            // Calculate percent ranges for each step
            const stepPercents = progressSteps.map((_, i) => Math.round(((i + 1) / progressSteps.length) * 90));

            // Smooth progress animation - updates every 100ms
            const smoothInterval = setInterval(() => {
                if (simulatedPercent < targetPercent) {
                    simulatedPercent = Math.min(simulatedPercent + 1, targetPercent);
                    const bar = document.getElementById('progressBar');
                    const percentEl = document.getElementById('progressPercent');
                    if (bar) bar.style.width = simulatedPercent + '%';
                    if (percentEl) percentEl.textContent = simulatedPercent + '%';
                }
            }, 100);

            // Step progression
            const progressInterval = setInterval(() => {
                if (currentStep < progressSteps.length - 1) {
                    currentStep++;
                    targetPercent = stepPercents[currentStep];
                    updateProgress(
                        simulatedPercent,
                        progressSteps[currentStep].text,
                        progressSteps[currentStep].detail,
                        currentStep + 1,
                        progressSteps.length
                    );
                } else {
                    // On last step, slowly increment to simulate ongoing work
                    if (targetPercent < 92) {
                        targetPercent += 1;
                        const subSteps = ['Analysiere Struktur...', 'Optimiere Kontrast...', 'Bereinige R√§nder...', 'Finalisiere...'];
                        const subStep = subSteps[Math.floor((targetPercent - 77) / 4) % subSteps.length];
                        document.getElementById('progressDetail').textContent = subStep;
                    }
                }
            }, 800);

            try {
                // Send file directly as FormData
                targetPercent = 5;
                updateProgress(5, progressSteps[0].text, '√úbertrage Datei...', 1, progressSteps.length);
                const formData = new FormData();
                formData.append('emlFile', file);

                const response = await fetch('/api/parse-eml', {
                    method: 'POST',
                    body: formData
                });

                clearInterval(progressInterval);
                clearInterval(smoothInterval);
                updateProgress(95, 'Verarbeite Antwort...', 'Server-Antwort wird analysiert', progressSteps.length, progressSteps.length);
                const text = await response.text();

                let data;
                try {
                    data = JSON.parse(text);
                } catch (parseErr) {
                    console.error('Server response:', text);
                    showProgress(false);
                    setStatus('Server-Fehler: Ung√ºltige Antwort');
                    return;
                }

                if (data.error) {
                    showProgress(false);
                    setStatus('Fehler: ' + data.error);
                    return;
                }

                const attachments = data.attachments || [];

                if (attachments.length === 0) {
                    showProgress(false);
                    setStatus('Keine Bild- oder PDF-Anh√§nge in der E-Mail gefunden.');
                    return;
                }

                updateProgress(100, 'Fertig!', 'Bild wurde erfolgreich verarbeitet', progressSteps.length, progressSteps.length);
                setTimeout(() => showProgress(false), 500);

                if (attachments.length === 1) {
                    // Single attachment - load directly
                    loadAttachmentImage(attachments[0]);
                } else {
                    // Multiple attachments - show selection dialog
                    showAttachmentSelection(data.metadata, attachments);
                }

            } catch (err) {
                clearInterval(progressInterval);
                clearInterval(smoothInterval);
                showProgress(false);
                console.error('EML Error:', err);
                setStatus('Fehler beim Verarbeiten der E-Mail: ' + err.message);
            }
        }

        function showAttachmentSelection(metadata, attachments) {
            const emlInfo = document.getElementById('emlInfo');
            emlInfo.innerHTML = `
                <strong>Betreff:</strong> ${metadata.subject || '(kein Betreff)'}<br>
                <strong>Von:</strong> ${metadata.from || '(unbekannt)'}<br>
                <strong>Datum:</strong> ${metadata.date || '(unbekannt)'}
            `;

            const list = document.getElementById('attachmentList');
            list.innerHTML = attachments.map((att, i) => `
                <div style="background: #0f4c75; padding: 15px; margin: 10px 0; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 15px;"
                     onclick="selectAttachment(${i})"
                     onmouseover="this.style.background='#1a6fa8'"
                     onmouseout="this.style.background='#0f4c75'">
                    <div style="font-size: 24px;">${att.is_pdf ? 'üìÑ' : 'üñºÔ∏è'}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: bold;">${att.filename}</div>
                        <div style="font-size: 12px; color: #aaa;">
                            ${att.is_pdf ? 'PDF-Dokument' : 'Bild'} ‚Ä¢ ${Math.round(att.size / 1024)} KB
                        </div>
                    </div>
                </div>
            `).join('');

            // Store attachments for selection
            window.pendingAttachments = attachments;

            document.getElementById('attachmentModal').classList.add('active');
            setStatus(`${attachments.length} Anh√§nge gefunden. Bitte w√§hlen Sie einen aus.`);
        }

        function selectAttachment(index) {
            const attachment = window.pendingAttachments[index];
            closeAttachmentModal();
            loadAttachmentImage(attachment);
        }

        function closeAttachmentModal() {
            document.getElementById('attachmentModal').classList.remove('active');
            window.pendingAttachments = null;
        }

        function loadAttachmentImage(attachment) {
            if (!attachment.data) {
                setStatus('Fehler: Anhang konnte nicht konvertiert werden.');
                return;
            }

            setStatus('Lade Anhang: ' + attachment.filename, true);

            imageData = attachment.data;

            // Build processing status message
            let processingMsg = '';
            if (attachment.processing) {
                const p = attachment.processing;
                if (p.orientation_corrected) {
                    processingMsg += `Orientierung korrigiert (${p.orientation_angle}¬∞). `;
                }
                if (p.deskew_applied) {
                    processingMsg += `Deskew angewendet (${p.deskew_angle}¬∞). `;
                }
                if (!p.orientation_corrected && !p.deskew_applied) {
                    processingMsg = 'Keine Korrektur n√∂tig. ';
                }
            }

            image = new Image();
            image.onload = function() {
                canvas.width = image.width;
                canvas.height = image.height;

                // Auto-detect zone based on template coordinates
                suggestZone();

                redraw();
                const statusMsg = processingMsg + 'Anhang geladen: ' + attachment.filename + '. Klicken Sie "Zone auto-erkennen".';
                setStatus(statusMsg);
                setMode('zone');
                setGuideStep('detect');  // Highlight auto-detect button
                document.getElementById('instructions').innerHTML =
                    '<strong>Schritt 2:</strong> Klicken Sie auf "Zone auto-erkennen" um die Tabellenbereiche automatisch zu erkennen.';
            };
            image.onerror = function() {
                setStatus('Fehler: Anhang konnte nicht als Bild geladen werden.');
            };
            image.src = imageData;
        }

        function setActiveZone(zoneName) {
            activeZone = zoneName;
            document.getElementById('activeZoneName').textContent = ZONE_COLORS[zoneName].name;
            document.getElementById('activeZoneName').style.color = ZONE_COLORS[zoneName].stroke;

            // Update button styles
            document.querySelectorAll('.zone-btn').forEach(btn => {
                btn.style.opacity = '0.5';
                btn.style.border = 'none';
            });
            const activeBtn = document.getElementById('btnZone' + zoneName.charAt(0).toUpperCase() + zoneName.slice(1));
            if (activeBtn) {
                activeBtn.style.opacity = '1';
                activeBtn.style.border = '3px solid white';
            }

            setStatus(`Zone "${ZONE_COLORS[zoneName].name}" ausgew√§hlt. Zeichnen Sie im Bild.`);

            // Deactivate edit mode when selecting a zone
            editMode = null;
            document.getElementById('editModeInfo').style.display = 'none';
            document.querySelectorAll('.edit-btn').forEach(btn => {
                btn.style.opacity = '1';
                btn.style.border = 'none';
            });
        }

        function setEditMode(mode) {
            editMode = mode;
            editSelectionRect = null;

            // Deactivate zone selection
            activeZone = null;
            document.querySelectorAll('.zone-btn').forEach(btn => {
                btn.style.opacity = '0.5';
                btn.style.border = 'none';
            });
            document.getElementById('activeZoneInfo').style.display = 'none';

            // Update edit mode buttons - highlight active one
            document.querySelectorAll('.edit-btn').forEach(btn => {
                btn.style.opacity = '1';
                btn.style.border = 'none';
            });
            if (mode === 'delete') {
                document.getElementById('btnDeleteObjects').style.border = '3px solid white';
            } else if (mode === 'add') {
                document.getElementById('btnAddObject').style.border = '3px solid white';
            }

            // Show edit mode info
            const infoDiv = document.getElementById('editModeInfo');
            const textSpan = document.getElementById('editModeText');
            infoDiv.style.display = 'block';

            if (mode === 'delete') {
                textSpan.innerHTML = '<span style="color:#dc3545;">L√∂schen:</span> Ziehen Sie ein Rechteck, dann <strong>Backspace</strong> zum L√∂schen';
                setStatus('L√∂schen-Modus: Ziehen Sie ein Rechteck um die zu l√∂schenden Objekte, dann dr√ºcken Sie Backspace.');
            } else if (mode === 'add') {
                textSpan.innerHTML = '<span style="color:#28a745;">Hinzuf√ºgen:</span> Ziehen Sie ein Rechteck um ein Objekt hinzuzuf√ºgen';
                setStatus('Hinzuf√ºgen-Modus: Ziehen Sie ein Rechteck um ein neues Objekt zu markieren.');
            }

            redraw();
        }

        // Save zones to server
        async function saveZonesToServer() {
            try {
                const response = await fetch('/api/zones', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ zones: zones })
                });
                const result = await response.json();
                if (result.success) {
                    console.log('Zones saved to server');
                } else {
                    console.error('Failed to save zones:', result.error);
                }
            } catch (e) {
                console.error('Error saving zones:', e);
            }
        }

        // Load zones from server
        async function loadZonesFromServer() {
            try {
                const response = await fetch('/api/zones');
                const result = await response.json();
                if (result.saved && result.zones) {
                    zones = result.zones;
                    // Ensure arrays are arrays (in case of old format)
                    if (!Array.isArray(zones.orders)) zones.orders = zones.orders ? [zones.orders] : [];
                    if (!Array.isArray(zones.codes)) zones.codes = zones.codes ? [zones.codes] : [];
                    updateOrdersButtonText();
                    updateCodesButtonText();
                    updateZoneInfo();
                    checkScanReady();
                    redraw();
                    console.log('Zones loaded from server');
                    return true;
                }
            } catch (e) {
                console.error('Error loading zones:', e);
            }
            return false;
        }

        async function suggestZone() {
            // Always enable auto-detect button when image is loaded
            document.getElementById('autoDetectBtn').disabled = false;

            // Try to load saved zones from server
            const loaded = await loadZonesFromServer();
            if (loaded) {
                setStatus('Gespeicherte Zonen wiederhergestellt. Klicken Sie "Zonen scannen" oder "Zone auto-erkennen" f√ºr neue Erkennung.');
                setActiveZone('orders');
                document.getElementById('zonePanel').style.display = 'block';
                // If zones are complete, enable scan but keep auto-detect available
                if (zones.orders.length > 0 && zones.names && zones.codes.length > 0) {
                    setGuideStep('scan');
                } else {
                    setGuideStep('detect');
                }
            } else {
                setStatus('Bild geladen. Klicken Sie "Zone auto-erkennen" oder zeichnen Sie manuell.');
                setActiveZone('orders');
                document.getElementById('zonePanel').style.display = 'block';
                setGuideStep('detect');
                updateZoneInfo();
            }
        }

        // Helper: Get canvas coordinates from mouse event
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // Helper: Get handle positions for a zone
        function getZoneHandles(zone) {
            if (!zone) return null;
            return {
                tl: { x: zone.x, y: zone.y },  // top-left
                tr: { x: zone.x + zone.width, y: zone.y },  // top-right
                bl: { x: zone.x, y: zone.y + zone.height },  // bottom-left
                br: { x: zone.x + zone.width, y: zone.y + zone.height },  // bottom-right
                center: { x: zone.x + zone.width / 2, y: zone.y + zone.height / 2 }  // center (for moving)
            };
        }

        // Helper: Check if point is near a handle
        function hitTestHandle(px, py, zone) {
            if (!zone) return null;
            const handles = getZoneHandles(zone);

            // Check corners first (higher priority)
            for (const [handleName, pos] of Object.entries(handles)) {
                if (handleName === 'center') continue;  // Check center separately
                const dist = Math.sqrt((px - pos.x) ** 2 + (py - pos.y) ** 2);
                if (dist <= HANDLE_HIT_RADIUS) {
                    return handleName;
                }
            }

            // Check if inside zone (for moving)
            if (px >= zone.x && px <= zone.x + zone.width &&
                py >= zone.y && py <= zone.y + zone.height) {
                return 'move';
            }

            return null;
        }

        // Helper: Find which zone and handle was clicked
        function findClickedZoneHandle(px, py) {
            // Check all zones, prioritize the active zone
            const zoneOrder = activeZone ?
                [activeZone, ...Object.keys(zones).filter(k => k !== activeZone)] :
                Object.keys(zones);

            for (const key of zoneOrder) {
                if (key === 'orders') {
                    // Check orders array (in reverse order - last drawn on top)
                    for (let i = zones.orders.length - 1; i >= 0; i--) {
                        const handle = hitTestHandle(px, py, zones.orders[i]);
                        if (handle) {
                            return { zoneKey: 'orders', ordersIndex: i, handle };
                        }
                    }
                } else if (key === 'codes') {
                    // Check codes array (in reverse order - last drawn on top)
                    for (let i = zones.codes.length - 1; i >= 0; i--) {
                        const handle = hitTestHandle(px, py, zones.codes[i]);
                        if (handle) {
                            return { zoneKey: 'codes', codesIndex: i, handle };
                        }
                    }
                } else {
                    const handle = hitTestHandle(px, py, zones[key]);
                    if (handle) {
                        return { zoneKey: key, handle };
                    }
                }
            }
            return null;
        }

        // Helper: Get cursor style for handle
        function getCursorForHandle(handle) {
            switch (handle) {
                case 'tl': case 'br': return 'nwse-resize';
                case 'tr': case 'bl': return 'nesw-resize';
                case 'move': return 'move';
                default: return 'crosshair';
            }
        }

        function startDraw(e) {
            if (!image) return;

            const coords = getCanvasCoords(e);

            // Edit mode has priority - don't check zone handles when adding/deleting objects
            if (editMode === 'add' || editMode === 'delete') {
                isDrawing = true;
                drawStart = coords;
                editSelectionRect = { x: coords.x, y: coords.y, width: 0, height: 0 };
                return;
            }

            // Check if we clicked on a zone handle (only when not in edit mode)
            const hit = findClickedZoneHandle(coords.x, coords.y);
            if (hit) {
                // Start dragging the handle
                let zone;
                if (hit.zoneKey === 'orders') {
                    zone = zones.orders[hit.ordersIndex];
                } else if (hit.zoneKey === 'codes') {
                    zone = zones.codes[hit.codesIndex];
                } else {
                    zone = zones[hit.zoneKey];
                }
                dragState = {
                    zoneKey: hit.zoneKey,
                    ordersIndex: hit.ordersIndex,
                    codesIndex: hit.codesIndex,
                    handle: hit.handle,
                    startX: coords.x,
                    startY: coords.y,
                    origZone: { ...zone }  // Copy original zone
                };
                canvas.style.cursor = getCursorForHandle(hit.handle);
                return;
            }

            // Otherwise, start drawing a new zone
            isDrawing = true;
            drawStart = coords;
        }

        function drawing(e) {
            const coords = getCanvasCoords(e);

            // Handle dragging (corner/move)
            if (dragState) {
                const dx = coords.x - dragState.startX;
                const dy = coords.y - dragState.startY;
                const orig = dragState.origZone;
                let newZone;

                switch (dragState.handle) {
                    case 'tl':  // Top-left: adjust x, y, width, height
                        newZone = {
                            x: orig.x + dx,
                            y: orig.y + dy,
                            width: orig.width - dx,
                            height: orig.height - dy
                        };
                        break;
                    case 'tr':  // Top-right: adjust y, width, height
                        newZone = {
                            x: orig.x,
                            y: orig.y + dy,
                            width: orig.width + dx,
                            height: orig.height - dy
                        };
                        break;
                    case 'bl':  // Bottom-left: adjust x, width, height
                        newZone = {
                            x: orig.x + dx,
                            y: orig.y,
                            width: orig.width - dx,
                            height: orig.height + dy
                        };
                        break;
                    case 'br':  // Bottom-right: adjust width, height
                        newZone = {
                            x: orig.x,
                            y: orig.y,
                            width: orig.width + dx,
                            height: orig.height + dy
                        };
                        break;
                    case 'move':  // Move entire zone
                        newZone = {
                            x: orig.x + dx,
                            y: orig.y + dy,
                            width: orig.width,
                            height: orig.height
                        };
                        break;
                }

                // Ensure minimum size
                if (newZone && newZone.width >= 20 && newZone.height >= 20) {
                    if (dragState.zoneKey === 'orders') {
                        zones.orders[dragState.ordersIndex] = newZone;
                    } else if (dragState.zoneKey === 'codes') {
                        zones.codes[dragState.codesIndex] = newZone;
                    } else {
                        zones[dragState.zoneKey] = newZone;
                    }
                }

                redraw();
                return;
            }

            // Not drawing? Just update cursor based on hover
            if (!isDrawing || !drawStart) {
                // Update cursor based on what's under mouse
                const hit = findClickedZoneHandle(coords.x, coords.y);
                canvas.style.cursor = hit ? getCursorForHandle(hit.handle) : 'crosshair';
                return;
            }

            const currentX = coords.x;
            const currentY = coords.y;

            // Edit mode: draw selection rectangle
            if (editMode) {
                editSelectionRect = {
                    x: Math.min(drawStart.x, currentX),
                    y: Math.min(drawStart.y, currentY),
                    width: Math.abs(currentX - drawStart.x),
                    height: Math.abs(currentY - drawStart.y)
                };
                redraw();
                return;
            }

            // Zone mode: update the active zone
            if (activeZone) {
                const newRect = {
                    x: Math.min(drawStart.x, currentX),
                    y: Math.min(drawStart.y, currentY),
                    width: Math.abs(currentX - drawStart.x),
                    height: Math.abs(currentY - drawStart.y)
                };

                if (activeZone === 'codes' || activeZone === 'orders') {
                    // For codes/orders: use temporary drawing rect (will be added to array on endDraw)
                    currentDrawingRect = newRect;
                } else {
                    zones[activeZone] = newRect;
                }
            }
            redraw();
        }

        function endDraw(e) {
            // End drag operation
            if (dragState) {
                let zoneName;
                if (dragState.zoneKey === 'orders') {
                    const label = dragState.ordersIndex === 0 ? 'Mo-Fr' : 'Sa';
                    zoneName = `Bestellmengen (${label})`;
                } else if (dragState.zoneKey === 'codes') {
                    zoneName = `Produktnummern ${dragState.codesIndex + 1}`;
                } else {
                    zoneName = ZONE_COLORS[dragState.zoneKey].name;
                }
                setStatus(`Zone "${zoneName}" angepasst.`);
                dragState = null;
                canvas.style.cursor = 'crosshair';
                updateZoneInfo();
                redraw();
                saveZonesToServer();  // Auto-save zones
                return;
            }

            // Edit mode: handle add object
            if (editMode === 'add' && editSelectionRect && editSelectionRect.width > 5 && editSelectionRect.height > 5) {
                addObjectAtSelection(editSelectionRect);
                editSelectionRect = null;
                isDrawing = false;
                redraw();
                return;
            }

            // Zone mode
            if (activeZone === 'orders' && isDrawing && currentDrawingRect && currentDrawingRect.width > 10 && currentDrawingRect.height > 10) {
                // Add to orders array (max 2)
                if (zones.orders.length < MAX_ORDER_ZONES) {
                    zones.orders.push(currentDrawingRect);
                    updateZoneInfo();
                    updateOrdersButtonText();
                    checkScanReady();
                    setStatus(`Bestellmengen-Zone ${zones.orders.length}/${MAX_ORDER_ZONES} hinzugef√ºgt.`);
                    saveZonesToServer();  // Auto-save zones
                } else {
                    setStatus(`Maximum ${MAX_ORDER_ZONES} Bestellmengen-Zonen erreicht. Shift+Klick zum L√∂schen.`);
                }
                currentDrawingRect = null;
            } else if (activeZone === 'codes' && isDrawing && currentDrawingRect && currentDrawingRect.width > 10 && currentDrawingRect.height > 10) {
                // Add to codes array (max 3)
                if (zones.codes.length < MAX_CODE_ZONES) {
                    zones.codes.push(currentDrawingRect);
                    updateZoneInfo();
                    updateCodesButtonText();
                    checkScanReady();
                    setStatus(`Produktnummern-Zone ${zones.codes.length}/${MAX_CODE_ZONES} hinzugef√ºgt.`);
                    saveZonesToServer();  // Auto-save zones
                } else {
                    setStatus(`Maximum ${MAX_CODE_ZONES} Produktnummern-Zonen erreicht. Shift+Klick zum L√∂schen.`);
                }
                currentDrawingRect = null;
            } else if (activeZone === 'names' && isDrawing && zones.names && zones.names.width > 10 && zones.names.height > 10) {
                updateZoneInfo();
                checkScanReady();
                setStatus(`Zone "${ZONE_COLORS.names.name}" definiert.`);
                saveZonesToServer();  // Auto-save zones
            }
            isDrawing = false;
            currentDrawingRect = null;
        }

        function handleCanvasClick(e) {
            if (isDrawing || results.length === 0) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // Check if click is inside any result blob
            let clickedIndex = -1;
            for (let i = 0; i < results.length; i++) {
                const r = results[i];
                if (clickX >= r.x && clickX <= r.x + r.width &&
                    clickY >= r.y && clickY <= r.y + r.height) {
                    clickedIndex = i;
                    break;
                }
            }

            if (clickedIndex !== -1) {
                highlightedResultIndex = clickedIndex;
                highlightResultRow(clickedIndex);
                startHighlightAnimation();
            } else {
                // Click outside - clear highlight
                highlightedResultIndex = -1;
                clearRowHighlight();
                stopHighlightAnimation();
                redraw();
            }
        }

        function handleCanvasDblClick(e) {
            if (isDrawing || results.length === 0) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // Check if double-click is inside any result blob
            for (let i = 0; i < results.length; i++) {
                const r = results[i];
                if (clickX >= r.x && clickX <= r.x + r.width &&
                    clickY >= r.y && clickY <= r.y + r.height) {
                    // Open review modal for this blob
                    openReview(i);
                    return;
                }
            }
        }

        function highlightResultRow(index) {
            // Find the table row with matching data-index
            const rows = document.querySelectorAll('#resultsBody tr');
            rows.forEach((row) => {
                row.classList.remove('highlighted');
                // Check if this row matches our result index
                if (parseInt(row.dataset.index) === index) {
                    row.classList.add('highlighted');
                    row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    // Focus the quantity input field
                    const input = row.querySelector('.quantity-input');
                    if (input) {
                        setTimeout(() => {
                            input.focus();
                            input.select();
                        }, 100);
                    }
                }
            });
        }

        function clearRowHighlight() {
            const rows = document.querySelectorAll('#resultsBody tr');
            rows.forEach(row => row.classList.remove('highlighted'));
        }

        function selectResultRow(index) {
            // Highlight the blob on the canvas
            highlightedResultIndex = index;
            startHighlightAnimation();

            // Highlight the row in the table
            const rows = document.querySelectorAll('#resultsBody tr');
            rows.forEach((row) => {
                row.classList.remove('highlighted');
                if (parseInt(row.dataset.index) === index) {
                    row.classList.add('highlighted');
                }
            });

            // Focus the quantity input
            const r = results[index];
            if (r) {
                const row = document.querySelector(`#resultsBody tr[data-index="${index}"]`);
                if (row) {
                    const input = row.querySelector('.quantity-input');
                    if (input) {
                        setTimeout(() => {
                            input.focus();
                            input.select();
                        }, 100);
                    }
                }
            }
        }

        function updateZoneInfo() {
            let html = '';
            for (const [key, color] of Object.entries(ZONE_COLORS)) {
                if (key === 'orders') {
                    // Handle orders as array
                    if (zones.orders.length > 0) {
                        html += `<div style="color:${color.stroke}; margin:5px 0;">‚úì ${color.name}: ${zones.orders.length}/${MAX_ORDER_ZONES} Zonen</div>`;
                        zones.orders.forEach((z, i) => {
                            const label = i === 0 ? 'Mo-Fr' : 'Sa';
                            html += `<div style="color:${color.stroke}; margin:2px 0 2px 15px; font-size:11px;">${label}: ${Math.round(z.width)}x${Math.round(z.height)}</div>`;
                        });
                    } else {
                        html += `<div style="color:#666; margin:5px 0;">‚óã ${color.name}: nicht definiert (0/${MAX_ORDER_ZONES})</div>`;
                    }
                } else if (key === 'codes') {
                    // Handle codes as array
                    if (zones.codes.length > 0) {
                        html += `<div style="color:${color.stroke}; margin:5px 0;">‚úì ${color.name}: ${zones.codes.length}/${MAX_CODE_ZONES} Zonen</div>`;
                        zones.codes.forEach((z, i) => {
                            html += `<div style="color:${color.stroke}; margin:2px 0 2px 15px; font-size:11px;">Zone ${i+1}: ${Math.round(z.width)}x${Math.round(z.height)}</div>`;
                        });
                    } else {
                        html += `<div style="color:#666; margin:5px 0;">‚óã ${color.name}: nicht definiert (0/${MAX_CODE_ZONES})</div>`;
                    }
                } else {
                    // Single zone (names)
                    const z = zones[key];
                    if (z) {
                        html += `<div style="color:${color.stroke}; margin:5px 0;">‚úì ${color.name}: ${Math.round(z.width)}x${Math.round(z.height)}</div>`;
                    } else {
                        html += `<div style="color:#666; margin:5px 0;">‚óã ${color.name}: nicht definiert</div>`;
                    }
                }
            }
            document.getElementById('zoneInfo').innerHTML = html;
        }

        function updateOrdersButtonText() {
            const btn = document.getElementById('btnZoneOrders');
            if (btn) {
                btn.textContent = `Bestellmengen (${zones.orders.length}/${MAX_ORDER_ZONES})`;
            }
        }

        function handleOrdersButtonClick(event) {
            if (event.shiftKey && zones.orders.length > 0) {
                // Shift+Click: remove last orders zone
                zones.orders.pop();
                updateOrdersButtonText();
                updateZoneInfo();
                checkScanReady();
                redraw();
                setStatus(`Letzte Bestellmengen-Zone gel√∂scht. (${zones.orders.length}/${MAX_ORDER_ZONES})`);
                saveZonesToServer();  // Auto-save zones
            } else {
                // Normal click: activate orders zone for drawing
                setActiveZone('orders');
            }
        }

        function updateCodesButtonText() {
            const btn = document.getElementById('btnZoneCodes');
            if (btn) {
                btn.textContent = `Produktnummern (${zones.codes.length}/${MAX_CODE_ZONES})`;
            }
        }

        function handleCodesButtonClick(event) {
            if (event.shiftKey && zones.codes.length > 0) {
                // Shift+Click: remove last codes zone
                zones.codes.pop();
                updateCodesButtonText();
                updateZoneInfo();
                redraw();
                setStatus(`Letzte Produktnummern-Zone gel√∂scht. (${zones.codes.length}/${MAX_CODE_ZONES})`);
                saveZonesToServer();  // Auto-save zones
            } else {
                // Normal click: activate codes zone for drawing
                setActiveZone('codes');
            }
        }

        function checkScanReady() {
            // Enable scan if at least one orders zone is defined
            const ready = zones.orders.length > 0;
            document.getElementById('scanBtn').disabled = !ready;
            document.getElementById('zonePanel').style.display = 'block';
        }

        function clearAllZones() {
            zones = { orders: [], names: null, codes: [] };
            results = [];
            updateOrdersButtonText();
            updateCodesButtonText();
            document.getElementById('scanBtn').disabled = true;
            document.getElementById('reviewBtn').disabled = true;
            document.getElementById('resultsBody').innerHTML =
                '<tr><td colspan="5" style="text-align:center;color:#666;">Noch keine Ergebnisse</td></tr>';
            document.getElementById('customerNumberInput').value = '';
            document.getElementById('kwInput').value = '';
            updateStats();
            updateZoneInfo();
            redraw();
            setStatus('Alle Zonen gel√∂scht. Klicken Sie "Zone auto-erkennen".');
            setMode('zone');
            if (image) {
                setGuideStep('detect');  // If image loaded, guide to auto-detect
            } else {
                setGuideStep('load');  // Otherwise guide to load file
            }
        }

        async function rotateDocument() {
            if (!image) {
                setStatus('Bitte zuerst ein Dokument laden.');
                return;
            }

            setStatus('Drehe Dokument um 180¬∞ und wende Deskew an...');

            try {
                // Create a canvas to rotate the image 180¬∞
                const rotateCanvas = document.createElement('canvas');
                rotateCanvas.width = image.width;
                rotateCanvas.height = image.height;
                const rotateCtx = rotateCanvas.getContext('2d');

                // Rotate 180¬∞ around center
                rotateCtx.translate(rotateCanvas.width / 2, rotateCanvas.height / 2);
                rotateCtx.rotate(Math.PI);
                rotateCtx.drawImage(image, -image.width / 2, -image.height / 2);

                // Get rotated image as base64
                const rotatedDataUrl = rotateCanvas.toDataURL('image/png');

                // Send to server for deskew and saving
                const response = await fetch('/api/rotate-and-deskew', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imageData: rotatedDataUrl
                    })
                });

                const data = await response.json();

                if (data.error) {
                    setStatus('Fehler: ' + data.error);
                    return;
                }

                // Load the corrected image
                const newImage = new Image();
                newImage.onload = function() {
                    image = newImage;
                    imageData = data.imageData;

                    // Resize canvas to new image dimensions
                    canvas.width = image.width;
                    canvas.height = image.height;

                    // Clear zones and results as they no longer match
                    zones = { orders: [], names: null, codes: [] };
                    results = [];
                    updateOrdersButtonText();
                    updateCodesButtonText();
                    document.getElementById('scanBtn').disabled = true;
                    document.getElementById('reviewBtn').disabled = true;
                    document.getElementById('resultsBody').innerHTML =
                        '<tr><td colspan="5" style="text-align:center;color:#666;">Noch keine Ergebnisse</td></tr>';
                    updateStats();
                    updateZoneInfo();

                    redraw();

                    const deskewInfo = data.deskewAngle ? ` (Deskew: ${data.deskewAngle}¬∞)` : '';
                    setStatus(`Dokument um 180¬∞ gedreht${deskewInfo}. Klicken Sie "Zone auto-erkennen".`);
                    setGuideStep('detect');
                };
                newImage.onerror = function() {
                    setStatus('Fehler beim Laden des gedrehten Bildes.');
                };
                newImage.src = data.imageData;

            } catch (error) {
                console.error('Rotate error:', error);
                setStatus('Fehler beim Drehen: ' + error.message);
            }
        }

        async function autoDetectZones() {
            if (!image) {
                setStatus('Bitte zuerst ein Dokument laden.');
                return;
            }

            setStatus('Erkenne Tabellenstruktur automatisch...', true);
            document.getElementById('autoDetectBtn').disabled = true;

            try {
                const response = await fetch('/api/detect-zones', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });

                const data = await response.json();

                if (data.error) {
                    setStatus('Auto-Erkennung fehlgeschlagen: ' + data.error);
                    document.getElementById('autoDetectBtn').disabled = false;
                    return;
                }

                // Apply detected zone
                if (data.zone) {
                    // Scale zone coordinates if image sizes differ
                    const scaleX = canvas.width / data.imageWidth;
                    const scaleY = canvas.height / data.imageHeight;

                    // Orders zone as array (first element is Mo-Fr)
                    zones.orders = [{
                        x: data.zone.x * scaleX,
                        y: data.zone.y * scaleY,
                        width: data.zone.width * scaleX,
                        height: data.zone.height * scaleY
                    }];

                    // Add Saturday zone if detected (second element)
                    if (data.zoneSaturday) {
                        zones.orders.push({
                            x: data.zoneSaturday.x * scaleX,
                            y: data.zoneSaturday.y * scaleY,
                            width: data.zoneSaturday.width * scaleX,
                            height: data.zoneSaturday.height * scaleY
                        });
                        console.log('Saturday zone detected:', zones.orders[1]);
                    }
                    updateOrdersButtonText();

                    // Apply product codes zone if detected (add to array)
                    if (data.zoneCodes) {
                        zones.codes = [{
                            x: data.zoneCodes.x * scaleX,
                            y: data.zoneCodes.y * scaleY,
                            width: data.zoneCodes.width * scaleX,
                            height: data.zoneCodes.height * scaleY
                        }];
                        updateCodesButtonText();
                        console.log('Product codes zone detected:', zones.codes);
                    }

                    // Apply product names zone if detected
                    if (data.zoneNames) {
                        zones.names = {
                            x: data.zoneNames.x * scaleX,
                            y: data.zoneNames.y * scaleY,
                            width: data.zoneNames.width * scaleX,
                            height: data.zoneNames.height * scaleY
                        };
                        console.log('Product names zone detected:', zones.names);
                    }

                    // Update row/column inputs
                    if (data.numRows) {
                        document.getElementById('numRows').value = data.numRows;
                    }
                    if (data.numCols) {
                        document.getElementById('numCols').value = data.numCols;
                    }

                    updateZoneInfo();
                    checkScanReady();
                    redraw();
                    saveZonesToServer();  // Auto-save detected zones

                    const debugInfo = data.debug || {};
                    const codesInfo = data.zoneCodes ? ' + Produktnummern' : '';
                    const namesInfo = data.zoneNames ? ' + Produktnamen' : '';
                    const saturdayInfo = data.zoneSaturday ? ' + Samstag' : '';
                    setStatus(`Zone erkannt: ${data.numRows} Zeilen, ${data.numCols} Spalten${namesInfo}${codesInfo}${saturdayInfo}. Klicken Sie "Zone scannen".`);
                    setMode('zone');
                    setGuideStep('scan');  // Highlight scan button
                    document.getElementById('instructions').innerHTML =
                        '<strong>Schritt 3:</strong> Klicken Sie auf "Zone scannen" um die Bestellmengen zu erkennen.';
                } else {
                    setStatus('Keine Zone erkannt. Bitte manuell zeichnen.');
                    setGuideStep('none');
                }

            } catch (err) {
                setStatus('Fehler bei Auto-Erkennung: ' + err.message);
            }

            document.getElementById('autoDetectBtn').disabled = false;
        }

        function redraw() {
            if (!image) return;
            ctx.drawImage(image, 0, 0);

            // Draw all zones
            for (const [key, value] of Object.entries(zones)) {
                const color = ZONE_COLORS[key];

                if (key === 'orders') {
                    // Draw all orders zones (array)
                    zones.orders.forEach((z, i) => {
                        ctx.strokeStyle = color.stroke;
                        ctx.lineWidth = (activeZone === 'orders') ? 3 : 2;
                        ctx.strokeRect(z.x, z.y, z.width, z.height);
                        ctx.fillStyle = color.fill;
                        ctx.fillRect(z.x, z.y, z.width, z.height);

                        // Label with index
                        const label = i === 0 ? 'Mo-Fr' : 'Sa';
                        ctx.fillStyle = color.stroke;
                        ctx.font = 'bold 12px sans-serif';
                        ctx.fillText(`${color.name} (${label})`, z.x + 5, z.y - 5);
                    });
                } else if (key === 'codes') {
                    // Draw all codes zones (array)
                    zones.codes.forEach((z, i) => {
                        ctx.strokeStyle = color.stroke;
                        ctx.lineWidth = (activeZone === 'codes') ? 3 : 2;
                        ctx.strokeRect(z.x, z.y, z.width, z.height);
                        ctx.fillStyle = color.fill;
                        ctx.fillRect(z.x, z.y, z.width, z.height);

                        // Label with index
                        ctx.fillStyle = color.stroke;
                        ctx.font = 'bold 12px sans-serif';
                        ctx.fillText(`${color.name} ${i+1}`, z.x + 5, z.y - 5);
                    });
                } else {
                    // Single zone (names)
                    const z = value;
                    if (!z) continue;

                    ctx.strokeStyle = color.stroke;
                    ctx.lineWidth = key === activeZone ? 3 : 2;
                    ctx.strokeRect(z.x, z.y, z.width, z.height);
                    ctx.fillStyle = color.fill;
                    ctx.fillRect(z.x, z.y, z.width, z.height);

                    // Label
                    ctx.fillStyle = color.stroke;
                    ctx.font = 'bold 12px sans-serif';
                    ctx.fillText(color.name, z.x + 5, z.y - 5);
                }
            }

            // Draw current drawing rect for orders/codes (while dragging)
            if ((activeZone === 'codes' || activeZone === 'orders') && currentDrawingRect) {
                const color = ZONE_COLORS[activeZone];
                ctx.strokeStyle = color.stroke;
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(currentDrawingRect.x, currentDrawingRect.y, currentDrawingRect.width, currentDrawingRect.height);
                ctx.setLineDash([]);
                ctx.fillStyle = color.fill;
                ctx.fillRect(currentDrawingRect.x, currentDrawingRect.y, currentDrawingRect.width, currentDrawingRect.height);
            }

            // Draw corner handles for all zones
            function drawHandles(zone, color, isActive) {
                if (!zone) return;
                const handles = getZoneHandles(zone);
                const size = HANDLE_SIZE;
                const halfSize = size / 2;

                for (const [handleName, pos] of Object.entries(handles)) {
                    if (handleName === 'center') continue;  // Don't draw center handle

                    // Draw handle square
                    ctx.fillStyle = isActive ? color : '#ffffff';
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.fillRect(pos.x - halfSize, pos.y - halfSize, size, size);
                    ctx.strokeRect(pos.x - halfSize, pos.y - halfSize, size, size);
                }
            }

            // Draw handles for all zones
            for (const [key, value] of Object.entries(zones)) {
                const color = ZONE_COLORS[key].stroke;
                const isActive = key === activeZone;

                if (key === 'orders') {
                    zones.orders.forEach((z, i) => {
                        drawHandles(z, color, isActive);
                    });
                } else if (key === 'codes') {
                    zones.codes.forEach((z, i) => {
                        drawHandles(z, color, isActive);
                    });
                } else if (value) {
                    drawHandles(value, color, isActive);
                }
            }

            // Draw grid on all orders zones
            zones.orders.forEach((zone, zoneIdx) => {
                const numRows = parseInt(document.getElementById('numRows').value) || 52;
                // First zone (Mo-Fr) has 5 cols, second zone (Sa) has 1 col
                const numCols = zoneIdx === 0 ? (parseInt(document.getElementById('numCols').value) || 5) : 1;
                const cellWidth = zone.width / numCols;
                const cellHeight = zone.height / numRows;

                // Vertical lines (columns)
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= numCols; i++) {
                    ctx.beginPath();
                    ctx.moveTo(zone.x + i * cellWidth, zone.y);
                    ctx.lineTo(zone.x + i * cellWidth, zone.y + zone.height);
                    ctx.stroke();
                }

                // Horizontal lines (rows) - draw every 5th line for visibility
                for (let i = 0; i <= numRows; i++) {
                    ctx.strokeStyle = (i % 5 === 0) ? 'rgba(0, 212, 255, 0.5)' : 'rgba(0, 212, 255, 0.15)';
                    ctx.beginPath();
                    ctx.moveTo(zone.x, zone.y + i * cellHeight);
                    ctx.lineTo(zone.x + zone.width, zone.y + i * cellHeight);
                    ctx.stroke();
                }

                // Draw column headers
                const days = zoneIdx === 0 ? ['Mo', 'Di', 'Mi', 'Do', 'Fr'] : ['Sa'];
                ctx.fillStyle = '#00d4ff';
                ctx.font = 'bold 14px sans-serif';
                for (let i = 0; i < numCols && i < days.length; i++) {
                    ctx.fillText(days[i], zone.x + i * cellWidth + cellWidth/2 - 10, zone.y - 20);
                }
            });

            // Draw detected cells
            results.forEach((r, i) => {
                const isHighlighted = (i === highlightedResultIndex);

                if (isHighlighted) {
                    // Pulsing glow effect for highlighted blob
                    const pulseIntensity = 0.5 + 0.5 * Math.sin(highlightPulse);
                    const glowSize = 3 + 4 * pulseIntensity;

                    // Outer glow
                    ctx.strokeStyle = `rgba(255, 255, 0, ${0.3 + 0.4 * pulseIntensity})`;
                    ctx.lineWidth = 12 + glowSize;
                    ctx.strokeRect(r.x - 4, r.y - 4, r.width + 8, r.height + 8);

                    // Middle ring
                    ctx.strokeStyle = `rgba(255, 100, 0, ${0.7 + 0.3 * pulseIntensity})`;
                    ctx.lineWidth = 6;
                    ctx.strokeRect(r.x - 2, r.y - 2, r.width + 4, r.height + 4);

                    // Inner bright ring
                    ctx.strokeStyle = 'rgba(255, 255, 255, 1.0)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(r.x, r.y, r.width, r.height);
                } else {
                    const color = r.reviewed ? 'rgba(40, 167, 69, 0.8)' :
                                  r.confidence < 0.5 ? 'rgba(255, 50, 50, 0.8)' :
                                  'rgba(255, 200, 0, 0.8)';
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(r.x, r.y, r.width, r.height);
                }

                // Label
                const labelColor = isHighlighted ? 'rgba(255, 255, 0, 1.0)' :
                                   r.reviewed ? 'rgba(40, 167, 69, 0.8)' :
                                   r.confidence < 0.5 ? 'rgba(255, 50, 50, 0.8)' :
                                   'rgba(255, 200, 0, 0.8)';
                ctx.fillStyle = labelColor;
                ctx.font = isHighlighted ? 'bold 18px sans-serif' : 'bold 14px sans-serif';
                ctx.fillText(r.digit || '?', r.x + 2, r.y - 4);

                // Store bounding box for click detection
                r._index = i;
            });

            // Draw edit selection rectangle
            if (editSelectionRect && editMode) {
                const color = editMode === 'delete' ? '#dc3545' : '#28a745';
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(editSelectionRect.x, editSelectionRect.y, editSelectionRect.width, editSelectionRect.height);
                ctx.fillStyle = editMode === 'delete' ? 'rgba(220, 53, 69, 0.2)' : 'rgba(40, 167, 69, 0.2)';
                ctx.fillRect(editSelectionRect.x, editSelectionRect.y, editSelectionRect.width, editSelectionRect.height);
                ctx.setLineDash([]);
            }
        }

        // Delete objects in selection rectangle
        function deleteObjectsInSelection() {
            if (!editSelectionRect || editMode !== 'delete') return;

            const sel = editSelectionRect;
            const initialCount = results.length;

            // Filter out objects that overlap with selection
            results = results.filter(r => {
                const overlaps = !(r.x + r.width < sel.x || r.x > sel.x + sel.width ||
                                   r.y + r.height < sel.y || r.y > sel.y + sel.height);
                return !overlaps;
            });

            const deletedCount = initialCount - results.length;
            if (deletedCount > 0) {
                setStatus(`${deletedCount} Objekt(e) gel√∂scht.`);
                updateResults();
                updateStats();
            } else {
                setStatus('Keine Objekte im markierten Bereich.');
            }

            editSelectionRect = null;
            redraw();
        }

        // Add new object at selection
        async function addObjectAtSelection(sel) {
            if (!zones.orders || zones.orders.length === 0) {
                setStatus('Bitte zuerst die Bestellmengen-Zone definieren.');
                return;
            }

            // Calculate center of selection
            const centerX = sel.x + sel.width / 2;
            const centerY = sel.y + sel.height / 2;

            // Find which orders zone the selection is in
            let foundZone = null;
            let zoneIndex = -1;
            for (let i = 0; i < zones.orders.length; i++) {
                const z = zones.orders[i];
                if (centerX >= z.x && centerX <= z.x + z.width &&
                    centerY >= z.y && centerY <= z.y + z.height) {
                    foundZone = z;
                    zoneIndex = i;
                    break;
                }
            }

            if (!foundZone) {
                setStatus('Auswahl liegt au√üerhalb der Bestellmengen-Zonen.');
                return;
            }

            // Determine column based on zone
            let columnName;
            if (zoneIndex === 0) {
                // Mo-Fr zone (5 columns)
                const COLUMNS_MOFR = ['Mo', 'Di', 'Mi', 'Do', 'Fr'];
                const cellWidth = foundZone.width / 5;
                const relX = centerX - foundZone.x;
                const col = Math.floor(relX / cellWidth);
                columnName = col >= 0 && col < COLUMNS_MOFR.length ? COLUMNS_MOFR[col] : 'Mo';
            } else {
                // Sa zone (1 column)
                columnName = 'Sa';
            }

            // Calculate row number based on first orders zone (Mo-Fr)
            const primaryZone = zones.orders[0];
            const numRows = parseInt(document.getElementById('numRows').value) || 52;
            const cellHeight = primaryZone.height / numRows;
            const relY = centerY - primaryZone.y;
            const row = Math.floor(relY / cellHeight);

            // Scan product info from zones using OCR
            let productName = '';
            let productCode = '';

            setStatus('Scanne Produktinfo...', true);

            try {
                const response = await fetch('/api/scan-row-info', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        y_center: centerY,
                        zoneCodes: zones.codes,
                        zoneNames: zones.names,
                        imageWidth: canvas.width,
                        imageHeight: canvas.height
                    })
                });
                const data = await response.json();
                if (data.product_code) productCode = data.product_code;
                if (data.product_name) productName = data.product_name;
                console.log(`OCR result: code='${productCode}', name='${productName}'`);
            } catch (e) {
                console.error('Error scanning row info:', e);
            }

            // Fallback to static lookup table if OCR failed
            if (!productName || !productCode) {
                const productInfo = getProductInfo(row);
                if (!productName) productName = productInfo.name;
                if (!productCode) productCode = productInfo.code;
            }

            console.log(`Adding object: row=${row}, day=${columnName}, name='${productName}', code='${productCode}'`);

            // Create new result entry
            const newResult = {
                digit: '',
                confidence: 1.0,
                row: row + 1,
                column: columnName,
                y_center: centerY,  // For sorting
                product_name: productName,
                product_code: productCode,
                x: sel.x,
                y: sel.y,
                width: sel.width,
                height: sel.height,
                reviewed: false,
                manuallyAdded: true
            };

            results.push(newResult);
            updateResults();
            updateStats();

            // Focus on the new entry's input field
            setTimeout(() => {
                const newIndex = results.length - 1;
                const inputId = `digitInput_${newIndex}`;
                const input = document.getElementById(inputId);
                if (input) {
                    input.focus();
                    input.select();
                    // Highlight the row
                    highlightedResultIndex = newIndex;
                    startHighlightAnimation();
                    highlightResultRow(newIndex);
                }
            }, 100);

            setStatus(`Neues Objekt in Zeile ${row + 1}, ${columnName} hinzugef√ºgt. Bitte Menge eingeben.`);
        }

        // Keyboard handler for Backspace (delete), Escape (cancel), Tab navigation
        document.addEventListener('keydown', function(e) {
            // Escape: cancel selection
            if (e.key === 'Escape' && editMode && editSelectionRect) {
                editSelectionRect = null;
                isDrawing = false;
                redraw();
                setStatus('Auswahl abgebrochen.');
                return;
            }

            // Backspace: delete objects in selection
            if (e.key === 'Backspace' && editMode === 'delete' && editSelectionRect) {
                // Don't delete if focus is in an input field
                if (document.activeElement.tagName === 'INPUT') return;
                e.preventDefault();
                deleteObjectsInSelection();
                return;
            }

            // Tab / Shift+Tab: navigate between results
            if (e.key === 'Tab') {
                // Skip if focus is on an input field (let browser handle normally)
                if (document.activeElement.tagName === 'INPUT') {
                    return;  // Don't prevent default, let Tab move between inputs
                }

                if (results.length === 0) {
                    return;  // No results to navigate
                }

                e.preventDefault();

                // Get sorted results for navigation (same order as displayed)
                const dayOrder = {'Mo': 0, 'Di': 1, 'Mi': 2, 'Do': 3, 'Fr': 4, 'Sa': 5, 'So': 6};
                const sortedIndices = results
                    .map((r, i) => ({index: i, y: r.y_center ?? r.y ?? 0, day: dayOrder[r.column] ?? 99}))
                    .sort((a, b) => {
                        if (Math.abs(a.y - b.y) > 20) return a.y - b.y;
                        return a.day - b.day;
                    })
                    .map(r => r.index);

                // Find current position in sorted order
                let currentPos = sortedIndices.indexOf(currentReviewIndex);
                if (currentPos === -1) currentPos = -1;

                // Calculate next position
                let nextPos;
                if (e.shiftKey) {
                    // Shift+Tab: go backwards
                    nextPos = currentPos <= 0 ? sortedIndices.length - 1 : currentPos - 1;
                } else {
                    // Tab: go forwards
                    nextPos = currentPos >= sortedIndices.length - 1 ? 0 : currentPos + 1;
                }

                const nextIndex = sortedIndices[nextPos];
                selectResultRow(nextIndex);

                // Scroll the result row into view
                const row = document.querySelector(`#resultsBody tr[data-index="${nextIndex}"]`);
                if (row) {
                    row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }

                // Show status feedback
                const r = results[nextIndex];
                setStatus(`Blob ${nextPos + 1}/${results.length}: ${r.product_name || 'Zeile ' + r.row} - ${r.column}`);
            }
        });

        async function scanZone() {
            if (!zones.orders) return;

            const startTime = performance.now();
            console.log(`[SCAN] Start: ${new Date().toISOString()}`);

            document.getElementById('scanBtn').disabled = true;

            try {
                // Row-based scanning: Find orders and scan horizontally for product info
                setStatus('Scanne Bestellungen und Produktinfos...', true);

                const response = await fetch('/api/scan-row-based', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        zone: zones.orders,
                        zoneNames: zones.names,
                        zoneCodes: zones.codes,
                        imageWidth: canvas.width,
                        imageHeight: canvas.height
                    })
                });

                const data = await response.json();

                if (data.error) {
                    setStatus('Fehler: ' + data.error);
                    document.getElementById('scanBtn').disabled = false;
                    return;
                }

                results = data.results || [];

                // Fallback to static table if OCR didn't find product info
                results.forEach(r => {
                    if (!r.product_code || !r.product_name) {
                        // Try to determine row from y_center
                        const rowHeight = zones.orders.height / 53;
                        const rowIndex = Math.floor((r.y_center - zones.orders.y) / rowHeight);
                        const staticInfo = getProductInfo(rowIndex);

                        if (!r.product_code) r.product_code = staticInfo.code;
                        if (!r.product_name) r.product_name = staticInfo.name;
                    }
                });

                updateResults();
                updateStats();
                redraw();

                const endTime = performance.now();
                const duration = ((endTime - startTime) / 1000).toFixed(2);
                console.log(`[SCAN] Ende: ${new Date().toISOString()}`);
                console.log(`[SCAN] Dauer: ${duration} Sekunden`);

                document.getElementById('scanBtn').disabled = false;
                document.getElementById('reviewBtn').disabled = results.length === 0;

                const pending = results.filter(r => !r.reviewed && r.confidence < 0.7).length;
                setStatus(`Scan abgeschlossen: ${results.length} Eintr√§ge, ${pending} zur √úberpr√ºfung. (${duration}s)`);
                setMode('review');
                setGuideStep('none');
                document.getElementById('instructions').innerHTML =
                    '<strong>Schritt 4:</strong> √úberpr√ºfen Sie die Ergebnisse. Klicken Sie auf eine Zeile oder "N√§chstes pr√ºfen" um unsichere Erkennungen zu korrigieren.';

            } catch (err) {
                setStatus('Fehler: ' + err.message);
                document.getElementById('scanBtn').disabled = false;
            }
        }

        function updateResults() {
            const tbody = document.getElementById('resultsBody');
            document.getElementById('orderCount').textContent = results.length;

            if (results.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:#666;">Keine Eintr√§ge gefunden</td></tr>';
                return;
            }

            // Sort by y position (top to bottom), then by day (Mo, Di, Mi, Do, Fr)
            const dayOrder = {'Mo': 0, 'Di': 1, 'Mi': 2, 'Do': 3, 'Fr': 4, 'Sa': 5, 'So': 6};
            const sortedResults = results
                .map((r, i) => ({...r, originalIndex: i}))
                .sort((a, b) => {
                    // Sort by y_center (top to bottom), fallback to row if y_center not available
                    const yA = a.y_center ?? a.y ?? a.row ?? 0;
                    const yB = b.y_center ?? b.y ?? b.row ?? 0;
                    if (Math.abs(yA - yB) > 20) return yA - yB;  // Different rows
                    // Same row - sort by day
                    const dayA = dayOrder[a.column] ?? 99;
                    const dayB = dayOrder[b.column] ?? 99;
                    return dayA - dayB;
                });

            tbody.innerHTML = sortedResults.map((r) => {
                const i = r.originalIndex;
                const rowClass = r.reviewed ? 'reviewed' : (r.confidence < 0.5 ? 'uncertain' : '');
                const icon = r.reviewed ? '‚úì' : (r.confidence < 0.5 ? '‚ö†' : '');
                // Use OCR-detected product info, fallback to row number
                const productCode = r.product_code || r.row;
                const productName = r.product_name || `Zeile ${r.row}`;
                return `
                    <tr class="${rowClass}" data-index="${i}" onclick="selectResultRow(${i})" ondblclick="openReview(${i})" style="cursor:pointer;">
                        <td>
                            <input type="text" class="quantity-input" value="${r.digit || '?'}"
                                   onclick="event.stopPropagation()"
                                   onchange="updateDigit(${i}, this.value)">
                        </td>
                        <td style="max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${productName}">${productName}</td>
                        <td>${productCode}</td>
                        <td>${r.column}</td>
                        <td>${icon}</td>
                    </tr>
                `;
            }).join('');
        }

        function updateStats() {
            const total = results.length;
            const reviewed = results.filter(r => r.reviewed).length;
            const pending = total - reviewed;

            document.getElementById('statTotal').textContent = total;
            document.getElementById('statReviewed').textContent = reviewed;
            document.getElementById('statPending').textContent = pending;
        }

        function openReview(index) {
            currentReviewIndex = index;
            const r = results[index];

            document.getElementById('reviewContext').textContent =
                `Zeile ${r.row}, ${r.column}`;

            // Create cell image from canvas
            const cellCanvas = document.createElement('canvas');
            cellCanvas.width = r.width;
            cellCanvas.height = r.height;
            const cellCtx = cellCanvas.getContext('2d');
            cellCtx.drawImage(image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
            document.getElementById('reviewImage').src = cellCanvas.toDataURL();

            document.getElementById('reviewModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('reviewModal').classList.remove('active');
            currentReviewIndex = -1;
        }

        function setDigit(digit) {
            if (currentReviewIndex < 0) return;

            if (digit === 'empty') {
                // Remove this result
                results.splice(currentReviewIndex, 1);
            } else {
                results[currentReviewIndex].digit = digit;
                results[currentReviewIndex].confidence = 1.0;
                results[currentReviewIndex].reviewed = true;

                // Save as training sample
                saveTrainingSample(currentReviewIndex, digit);
            }

            closeModal();
            updateResults();
            updateStats();
            redraw();
        }

        function updateDigit(index, value) {
            if (value && /^[0-9]$/.test(value)) {
                const oldDigit = results[index].digit;
                results[index].digit = value;
                results[index].reviewed = true;
                results[index].confidence = 1.0;

                // Save as training sample if digit changed
                if (oldDigit !== value) {
                    saveTrainingSample(index, value);
                    setStatus(`Ziffer "${value}" gespeichert als Trainingsbeispiel`);
                }

                updateStats();
                updateResults();
                redraw();
            }
        }

        function reviewNext() {
            const index = results.findIndex(r => !r.reviewed && r.confidence < 0.7);
            if (index >= 0) {
                openReview(index);
            } else {
                setStatus('Alle Eintr√§ge wurden √ºberpr√ºft!');
            }
        }

        async function saveTrainingSample(index, digit) {
            const r = results[index];
            // Create cell image data
            const cellCanvas = document.createElement('canvas');
            cellCanvas.width = r.width;
            cellCanvas.height = r.height;
            const cellCtx = cellCanvas.getContext('2d');
            cellCtx.drawImage(image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);

            try {
                await fetch('/api/save-training-sample', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        digit: digit,
                        imageData: cellCanvas.toDataURL(),
                        row: r.row,
                        column: r.column
                    })
                });
            } catch (e) {
                console.error('Failed to save training sample:', e);
            }
        }

        function exportResults() {
            const customerNumber = document.getElementById('customerNumberInput').value.trim() || 'unbekannt';
            const kw = document.getElementById('kwInput').value.trim() || 'unbekannt';

            const exportData = {
                customerNumber: customerNumber,
                kw: kw,
                orders: results.map(r => ({
                    quantity: r.digit,
                    productCode: r.product_code || r.row,
                    productName: r.product_name || `Zeile ${r.row}`,
                    column: r.column,
                    confidence: r.confidence,
                    reviewed: r.reviewed || false
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bestellungen_' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function setStatus(msg, isActive = false) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = msg;
            if (isActive) {
                statusEl.classList.add('active');
            } else {
                statusEl.classList.remove('active');
            }
        }

        function showProgress(show) {
            const container = document.getElementById('progressContainer');
            if (show) {
                container.classList.add('active');
            } else {
                container.classList.remove('active');
            }
        }

        function updateProgress(percent, stepText, detailText, currentStep, totalSteps) {
            const bar = document.getElementById('progressBar');
            const percentEl = document.getElementById('progressPercent');
            const stepEl = document.getElementById('progressStep');
            const detailEl = document.getElementById('progressDetail');

            bar.style.width = percent + '%';
            percentEl.textContent = percent + '%';
            stepEl.textContent = `Schritt ${currentStep}/${totalSteps}`;
            detailEl.textContent = detailText;

            // Also update status text
            setStatus(stepText, true);
        }

        function setMode(mode) {
            const indicator = document.getElementById('modeIndicator');
            if (mode === 'zone') {
                indicator.textContent = 'Modus: Zone definieren';
                indicator.className = 'mode-indicator mode-zone';
            } else {
                indicator.textContent = 'Modus: Ergebnisse pr√ºfen';
                indicator.className = 'mode-indicator mode-review';
            }
        }

        // User guidance: highlight next action button
        function setGuideStep(step) {
            // Remove blink from all guide buttons
            const guideButtons = ['loadFileBtn', 'autoDetectBtn', 'scanBtn'];
            guideButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.classList.remove('guide-blink');
            });

            // Add blink to the appropriate button
            switch(step) {
                case 'load':
                    document.getElementById('loadFileBtn')?.classList.add('guide-blink');
                    break;
                case 'detect':
                    document.getElementById('autoDetectBtn')?.classList.add('guide-blink');
                    break;
                case 'scan':
                    document.getElementById('scanBtn')?.classList.add('guide-blink');
                    break;
                case 'none':
                default:
                    // No button blinking
                    break;
            }
        }

        // Update grid preview when row/col count changes
        document.getElementById('numRows').addEventListener('change', redraw);
        document.getElementById('numCols').addEventListener('change', redraw);

        // Load training stats
        async function loadTrainingStats() {
            try {
                const response = await fetch('/api/training-stats');
                const data = await response.json();
                const stats = data.stats || {};

                const digits = Object.keys(stats).sort();
                if (digits.length === 0) {
                    document.getElementById('trainingStats').innerHTML =
                        '<span style="color: #f66;">Keine Trainingsbeispiele</span><br>' +
                        '<small>Korrigieren Sie Erkennungen um Beispiele zu sammeln.</small>';
                } else {
                    const total = Object.values(stats).reduce((a, b) => a + b, 0);
                    let html = `<strong>${total} Beispiele</strong><br>`;
                    html += digits.map(d => `<span style="color:#0f0;">${d}</span>: ${stats[d]}`).join(' | ');
                    document.getElementById('trainingStats').innerHTML = html;
                }
            } catch (err) {
                document.getElementById('trainingStats').innerHTML = 'Fehler beim Laden';
            }
        }

        // Load training stats on page load
        loadTrainingStats();

    </script>
</body>
</html>
